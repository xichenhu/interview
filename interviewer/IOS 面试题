UI
1、事件响应链是如何传递的？

手势的点击会发生两个重要事情，事件传递和事件响应。

事件传递：从UIApplication开始，到window，再逐步往下层（子视图）找，直到找到最深层的子视图，其为first responder。用到的判断方法是pointInside:withEvent和hitTest:withEvent。

事件响应：从识别到的视图（first responder）开始验证能否响应事件，如果不能就交给其上层（父视图）视图，如果能相应将不再往下传递，如果直到找到UIApplication层还没有相应，那就忽略该次点击。用到的判断方法是touchesBegan:withEvent、touchesMoved:withEvent等。

这两个过程大致的相反的。


数据结构与算法
1、什么是Hash表，什么是Hash碰撞，解决Hash碰撞有什么方法？

哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。我们常用的Dictionary就是一种Hash表。

那什么是Hash碰撞呢，我们知道Hash表的查找是通过键值进行定位的，当两个不同的输入对应一个输出时，即为Hash碰撞，也被称为Hash冲突。

如果使用字典的例子你可能联想不到冲突的情况，我们假设另一种情况：假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10。我们使用的hash函数是对9取余。这样的话会出现hash(5)=5，hash(28)=1，hash(19)=1。28和19都对应一个地址，这就出现了Hash冲突。

解决Hash冲突的方式有开放定址法和链地址法。

2、如何遍历二叉树？
二叉树的遍历有三种方式，对于上面这棵二叉树，他们的遍历结果为：

前序遍历：根节点 > 左子节点 > 右子节点。

10，6，4，8，14，12，16

中序遍历：左子节点 > 根节点 > 右子节点。

4，6，8，10，12，14，16

后序遍历：左子节点 > 右子节点 > 根节点。

4，8，6，12，16，14，10

一、硬技术篇

1.对象方法和类方法的区别？

对象方法能个访问成员变量。
类方法中不能直接调用对象方法，想要调用对象方法，必须创建或者传入对象。
类方法可以和对象方法重名。

3.深拷贝和浅拷贝

所谓深浅指的是是否创建了一个新的对象（开辟了新的内存地址）还是仅仅做了指针的复制。
copy和mutableCopy针对的是可变和不可变，凡涉及copy结果均变成不可变，mutableCopy均变成可变。
mutableCopy均是深复制。
copy操作不可变的是浅复制，操作可变的是深赋值。

9. 什么是线程安全？

多条线程同时访问一段代码，不会造成数据混乱的情况

10. 你接触到的项目，哪些场景运用到了线程安全？

22.网络协议

TCP三次握手和四次挥手？
三次握手

1.客户端向服务端发起请求链接，首先发送SYN报文，SYN=1，seq=x,并且客户端进入SYN_SENT状态 2.服务端收到请求链接，服务端向客户端进行回复，并发送响应报文，SYN=1，seq=y,ACK=1,ack=x+1,并且服务端进入到SYN_RCVD状态 3.客户端收到确认报文后，向服务端发送确认报文，ACK=1，ack=y+1，此时客户端进入到ESTABLISHED，服务端收到用户端发送过来的确认报文后，也进入到ESTABLISHED状态，此时链接创建成功

为什么需要三次握手： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。假设这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。

四次挥手

1.客户端向服务端发起关闭链接，并停止发送数据 2.服务端收到关闭链接的请求时，向客户端发送回应，我知道了，然后停止接收数据 3.当服务端发送数据结束之后，向客户端发起关闭链接，并停止发送数据 4.客户端收到关闭链接的请求时，向服务端发送回应，我知道了，然后停止接收数据

HTTP和HTTPS有什么区别？

HTTP协议是一种使用明文数据传输的网络协议。
HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息让然是安全的。这就是HTTP和HTTPS的最大区别。
HTTPS的加密方式？

Https采用对称加密和非对称加密结合的方式来进行通信。

Https不是应用层的新协议，而是Http通信接口用SSL和TLS来加强加密和认证机制。

对称加密： 加密和解密都是同一个钥匙
非对称加密：密钥承兑出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密

程序卡顿的原因？

正常渲染流程
CPU计算完成之后交给GPU，来个同步信号Vsync 将内容渲染到屏幕上
非正常（卡顿/掉帧）的流程
CPU计算时间正常或者慢，GPU渲染时间长了， 这时候Vsync信号， 由于没有绘制完全，CUP开始计算下一帧，当下一帧正常绘制成功之后，把当前没有绘制完成的帧丢弃， 显示了下一帧，于是这样就造成了卡顿。 需要注意的是：Vsync时间间隔是固定的， 比如60帧率大的Vsync 是每16ms就执行一个一次，类似定时器一样

操作系统
进程和线程之间的区别
操作系统中堆和栈的区别
死锁的解决和产生

数据结构
二叉树的各种遍历：先序、中序、后序、层序

5.面向对象的三大基本特征:（编程思想 简单）
封装、继承、多态

7.面向对象的五大基本原则 (编程思想 较难)
　　1、单一职责原则（SRP）
    　　2、开放封闭原则（OCP）
    　　3、里氏替换原则（LSP）
    　　4、依赖倒置原则（DIP）
    　　5、接口隔离原则（ISP）

8.介绍有哪些设计原则（懂iOS基础的 较 难）
	单一职责原则 开闭原则：OC中category，通过runtime 添加交换方法等，都
	是开闭原则
	里氏替换原则 接口隔离原则
	依赖倒置原则
	迪米特法则
	组合/聚合复用原则


iOS方向的面试问题
循环引用的问题，什么场景下会有循环引用的问题（delegate和block使用不当）
单个UIViewController的生命周期
深浅拷贝主要的区别和使用场景



1、面向对象和面向过程的区别?
2、对象方法和类方法的区别?


7. 浅复制和深复制的区别?
答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。 深层复制：复制引用对象本身。


9. 优化你是从哪几方面着手？
一、首页启动速度 启动过程中做的事情越少越好（尽可能将多个接口合并） 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目） 在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据） 
二、页面浏览速度 json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson） 数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录） 数据压缩（大数据也可以压缩返回，减少流量，加快反应速度） 内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定） 延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载） 算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序） 
三、操作流畅度优化 Tableview 优化（tableview cell的加载优化） ViewController加载优化（不同view之间的跳转，可以提前准备好数据） 
四、数据库的优化 数据库设计上面的重构 查询语句的优化 分库分表（数据太多的时候，可以分不同的表或者库） 
五、服务器端和客户端的交互优化 客户端尽量减少请求 服务端尽量做多的逻辑处理 服务器端和客户端采取推拉结合的方式（可以利用一些同步机制） 通信协议的优化（减少报文的大小） 电量使用优化（尽量不要使用后台运行） 六、非技术性能优化 产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题） 界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯） 代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝） code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）

17. 如何访问并修改一个类的私有属性?
有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。



20. Category(分类)，Extension(扩展)和继承的区别
答：
1.分类 category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的 
2.扩展 iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的 
3.继承 在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量


21. 简述内存分区情况
1).代码区：存放函数二进制代码 
2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量 
3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 
4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数




23. 对于Run Loop的理解
RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；
每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；
在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；
NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；
实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。


27. TCP协议三次握手
TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。

30. ViewController生命周期
按照执行顺序排列： 1). initWithCoder：通过nib文件初始化时触发。 2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。
3). loadView：开始加载视图控制器自带的view。 4). viewDidLoad：视图控制器的view被加载完成。


从输出url到页面展现到底产生了什么
1、输出地址
2、浏览器查找域名的 IP 地址　　
3、浏览器向 web 服务器发送一个 HTTP 申请
4、服务器的永恒重定向响应
5、浏览器跟踪重定向地址
6、服务器解决申请
7、服务器返回一个 HTTP 响应　
8、浏览器显示 HTML
9、浏览器发送申请获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）




1. #include、#import、@class的区别?

在C 语言中, 我们使用 #include 来引入头文件,如果需要防止重复导入需要使用#ifndef...#define...#endif
在OC语言中, 我们使用#import来引入头文件,可以防止重复引入头文件,可以避免出现头文件递归引入的现象。
@class仅用来告诉编译器，有这样一个类，编译代码时，不报错,不会拷贝头文件.如果需要使用该类或者内部方法需要使用 #import导入


3. New 作用是什么?

向计算机(堆区)申请内存空间;
给实例变量初始化;
返回所申请空间的首地址;


4.OC实例变量的修饰符? 及作用范围?

@puplic

1.可以在其他类中访问被@public修饰的成员变量 2.也可以在本类中访问被@public修饰的成员变量 3.可以在子类中访问父类中被@public修饰的成员变量

@private

1.不可可以在其他类中访问被@private修饰的成员变量 2.也可以在本类中访问被@private修饰的成员变量 3.不可以在子类中访问父类中被@private修饰的成员变量

@protected (默认情况下所有的实例变量都是protected)

1.不可可以在其他类中访问被@protected修饰的成员变量 2.也可以在本类中访问被@protected修饰的成员变量 3.可以在子类中访问父类中被@protected修饰的成员变量

@package

介于public和private之间的,如果是在其他包中访问就是private,在当前代码中访问就是public.

